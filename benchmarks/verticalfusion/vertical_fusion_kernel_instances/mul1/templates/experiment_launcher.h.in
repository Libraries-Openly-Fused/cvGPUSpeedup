/* Copyright 2023-2025 Oscar Amoros Huguet
   Copyright 2025 Albert Andaluz Gonz√°lez
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License. */
   
#ifndef MUL_LAUNCHER_H
#define MUL_LAUNCHER_H

#include <opencv2/cudaimgproc.hpp> // General OpenCV include
#include <opencv2/core/cuda.hpp>   // For GpuMat, Stream, Size
#include <array>                   // For std::array
#include <stdexcept>               // For std::runtime_error

// Paths for these dependencies need to be resolved by include_directories
#include <benchmarks/verticalfusion/vertical_fusion_kernel_instances/mul1/mulOpType.cuh>
#include <benchmarks/verticalfusion/vertical_fusion_kernel_instances/mul1/realBatch.h>

// Placeholder for including all generated mul@N@.h files
// e.g., #include "mul1.h"
//       #include "mul2.h"
//       ...
@GENERATED_MUL_INCLUDES@

template <int NumOps> // NumOps is the 1-based experiment number
void launchMulPipeline(const std::array<cv::cuda::GpuMat, REAL_BATCH>& crops,
                  const cv::cuda::Stream& cv_stream,
                  const float& alpha,
                  const cv::cuda::GpuMat& d_tensor_output,
                  const cv::Size& cropSize,
                  const MulFuncType& dFunc) {

    // Compile-time check for the validity of NumOps (experiment number N)
    static_assert(NumOps > 0 && NumOps <= @NUM_EXPERIMENTS_TOTAL@,
                  "NumOps (experiment number) is out of the compiled range.");

    // Your original check was: if constexpr (NumOps > 13002)
    // That 13002 likely refers to a maximum *VALUE*, not the experiment index NumOps.
    // The check against VALUE would be implicit in how many experiments you compile.
    // If you still need a check against a max VALUE, it would be more complex here,
    // as this function is templated on N (NumOps), not VALUE.

// Macro to dispatch to the correct launchMul<N> function
#define DISPATCH_TO_MUL_INSTANCE(INSTANCE_N) \
    if constexpr (NumOps == INSTANCE_N) { \
        launchMul##INSTANCE_N(crops, cv_stream, alpha, d_tensor_output, cropSize, dFunc); \
        return; /* Exit after dispatching */ \
    }

// Placeholder for the series of dispatch calls
// e.g., DISPATCH_TO_MUL_INSTANCE(1)
//       DISPATCH_TO_MUL_INSTANCE(2)
//       ...
@GENERATED_DISPATCH_CALLS@

#undef DISPATCH_TO_MUL_INSTANCE
    // Control should not reach here if static_assert passes and NumOps is within range,
    // as one of the if constexpr branches would have been taken and returned.
}

#endif // MUL_LAUNCHER_H